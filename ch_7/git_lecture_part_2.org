:PROPERTIES:
:ID:       72396578-1195-492f-8aee-f6d952363e1b
:END:
#+title: git lecture part 2
#+date: 2021-11-01 11:13
:DRAWER:
#+LATEX_CLASS: jsarticle
#+LATEX_HEADER: \newcommand{\headauthor}{Yasushi Sakai}
#+LATEX_HEADER: \newcommand{\headtitle}{git lecture part 2}
#+FILETAGS: :draft:
#+OPTIONS: title:nil
:END:

* introduction

後半である第二回は、思想？編として、why の部分をすこし掘りさげる。

話をわかりやすくする為に、80%のただしさで説明しているものと思っていてください。

** アジェンダ

*** [[id:53b49758-e540-45bf-a140-9c598a0b4640][前半]]

*** 後半

*git と都市・建築にどんな関連性があるのか*

1. github 上での情報公開時の注意
2. OSS 文化とライセンス
3. クレジットの話、デザインの所有権、ライセンス
4. データ構造からつながる分野
5. 設計・デザイン業での使われ方
   - CAD と BIM
6. 建築情報学会での利用
   - 学術委員会での利用

* github 上での情報公開時の注意

使い方は練習次第で、この他にも色々できるのですが、情報の公開時に覚えておいたほう
がいい事があります。

プログラムであれ、図面ファイルであれ、コンセプト文であれ、公開した瞬間から、著作
権が発生します。Github では、何もライセンスを指定しなければ、通常のコピーライト
になります。すなわち、著作者の許可なしに使ったり、公開、配布してはいけないことに
なります。日記ならいいですが、たとえばそれが使えるものだとして、Github という性
質上だれもがコピーしやすい状況にあるのに、著作権がかかっているという不思議な状態
になります。

他人のものを使った場合はこの著作権に違反していないか(オープンソースライセンスが
無いものをコピーしていないか)は注意すれば問題になることはさけやすいですが、それ
以外に以下の状況に注意すべき。

** 研究活動の一環の場合、教官、大学、会社の知財管理ポリシーを確認しておく

公開するかしたとしてもどんなライセンスで公開するかは、超大事な戦略です。研究室の
研究活動の一環でやる場合は、まず指導教官と相談しましょう。共同研究で企業からお金
が入っていたり、あるいは、助成金でも、なんらかの NDA(Non Disclosure Agreement; 機
密保持契約)でやっているかもしれません。

ここまで考えがまわっていなければ、学生や研究員の著作や仕事に対する戦略やポリシー
が無いということになります。

研究室によっては、取りあえず、全てプライベートレポジトリで管理というポリシーも全
然あるだろうし、場所によっては、クラウドの利用を禁止している所もあるでしょう、そ
の場合の管理の方法もあります。まず、github と git の区別もつかずに、危いから使わ
ないのは、頭わるすぎ。


* OSS 文化とライセンス

どんなライセンスがあるか。

** デフォルトは(なにもしなければ) Copyright

** ソフトウェアライセンス

OSS ライセンスといわれているものは、基本的商用可。

https://en.wikipedia.org/wiki/Permissive_software_license

*** Permissive licence (MIT licence, Apache)

*** Protective, Contagious licence (GPL)
そのライセンス下で公開されたプログラムを使う場合は、同じラインセンス下(と指定す
る条約下)で公開しないといけない。 -> 伝染性あるライセンス

コピーレフトともいわれる。

有名なところだと、GPL v3 と Apple (etc, ~bash~)
Apple は GPLv3 のソフトウェアは使えない。

*** Combined licence

Rust のライブラリだと、ダブルライセンスも見かける。

https://github.com/rust-lang/cargo/


** クリエイティブ・コモンズ

https://creativecommons.org/

上の話と似ている。

* データ構造からつながる分野

git のデータ構造として、履歴を保存するために ADG (Acyclic Directed Graph)構造を
もっていて、現コミットが前のコミット ID を憶えていると説明しましたが、前のコミッ
ト ID を替える場合は、現コミット ID を計算しなおす必要があります。そのまま転用とい
うわけにはいきませんが、ブロックチェーン技術の従兄弟にあたるような仕組みです。

コミット ID の計算につかわれているのが、ハッシュ関数というアルゴリズムです。

** ハッシュアルゴリズム

#+begin_src bash :results output :wrap src text
echo a | sha1sum
#+end_src

この場合 ~a~ を入力として以下がかえってきます。

#+begin_src text
3f786850e387550fdab836ed7e6dc881de23001b
#+end_src

~a~ を入れるかぎり、上になります。ただすこしでもかえると、

#+begin_src bash :results output :wrap src text
echo ab | sha1sum
#+end_src

#+begin_src text
5277cbb45a15902137d332d97e89cf8136545485
#+end_src

と違う値がかえってきます。入力はなんでもよくて[fn:2] 返ってくる値は必ず決った長
さです(上の場合、41 文字)。なんでもいいなら、数 MB のファイルでも、'abc' でもい
いわけで、その 2 つの出力が同じなら、元の入力が同じということがいえます。

短かければ、比較も簡単ですが、たとえば、数 MB のデータで一箇所 byte がかわった場
合など、人間だとそれを特定するのは難しそうです。

実装してみると、(数学的な証明はおいておいて)結構簡単です、ルービックキューブをぐ
ちゃぐちゃしているイメージです。

** いろんなところでつかわれている

git でも使われていますが、とんでもなく汎用的なアルゴリズムなので、どんなハッシュ
の亜種というかたちで、おそらく、全てのプログラムで使われています。

それが、地球環境問題への懸念とまで発展したのが、bitcoin など仮想通貨です。取り引
きの情報になんでもいいから情報を足して、いちばん 0 が多いやつを探しあてたやつに
お金あげる。

#+begin_src bash :results output :wrap src text
echo "酒井から杉原さんに10万円。" | sha1sum
#+end_src

#+begin_src text
c664adb69739087a96dc73b69cf0dfc590acd1e0  -
#+end_src

#+begin_src bash :results output :wrap src text
echo "酒井から杉原さんに10万円。+a" | sha1sum
#+end_src

#+begin_src text
a16a65beab23a0bbb9038685bc81d8c5fc7fd1f9  -
#+end_src

#+begin_src bash :results output :wrap src text
echo "酒井から杉原さんに10万円。+b" | sha1sum
#+end_src

#+begin_src text
00c1b81b5778840eccb6a4e652492d132c7070ef  -
#+end_src

と、 ~+b~ を足すと、 ~00c1~ になって、 ~+a~ のときよりも、0が多いですね。この、
~+b~ をさがしあてるという、労働が Proof of Work の'Work' の部分になります。

この計算はグラフィックボード(行列処理をする部品、一番馴染みがあるのが画面の描画)
で並行的に高速で計算できるので、グラボが品薄になっています。で、この計算の物量が
はんぱでなく、グラボの電力消費もあいまって、電気つかいすぎでは？と指摘されていま
す。

** git も bitcoin

ハッシュアルゴリズムを通じて、一見関係ないものがつながるのですが、git が 2005 年
あたり、bitcoin の whitepaper が 2008 年なので、開発された時が近かったり、いろい
ろ共通点があるとおもいます。

前のコミット ID を含めて次のコミット ID を計算して数珠つなぎにするのが git でし
たが、bitcoin は似た方法で、通帳の取り引きを数珠つなぎにしています。

** 機械-機械の合意形成

両プログラム結局は "なにが先にきて、なにが後に来たか" という履歴をとっている。

git はコードの変更だし、bitcoin は取り引きの順番。この履歴に齟齬がないように、順
番に合意形成をしている。だから、先のアルゴリズムもコンセンサスアルゴリズムといわ
れたりします。 この複数の計算ノードが値に対して合意をとっていくことをあつかう分
野が、分散システムになります。[fn:3]


** 人間人間の合意形成

機械は意思を決定したりしませんが、値に合意する時代です。人間も集団になると合意形
成しますが、 いろんな方法を考えてきました。投票の方法しかり、民主主義しかり、あ
るいは、組織をつくったり。

-[[https://www.figma.com/file/eTmMwxXWEH3WF2IyOlrAPu/Portfolio?node-id=0%3A1][時間があれば、酒井のとりくみ]]-

* デザイン業務での使われ方

とりあえず、「全部 git にいれとけ」というのが対応策になります。本来ならば binary
ファイル (生のバイトの羅列、テキスト帳で開く事を想定していないもの) は行ごと比較
ができないので、原理主義にたつと binary は違う保存方法がいいということになります
が、行ごとの差分(コマンド名にちなんで diff といいます) がみえなくても、いつ誰が
なんの為に変更したかという履歴は残せるので、それだけでも価値があります。text で
保存できるようなもの、仕上げ表、設計アブスト、目次、標準詳細系は行ごとの履歴がみ
れるとなおいいかもしれません。BIM でいったら、ファミリ定義ファイルも履歴が積める
といいですね。

** CAD と BIM

- バージョニングが中心的なものは[[https://www.onshape.com/en/][少ない]]

ましては、現状 BIM はやはり、空間情報の記述としてのウェイトが高い。が、プロジェ
クト単位設計(施工)過程での変化、その後の FM 的な使われ方、時間的差分に強いものが
出てきもいいような印象。

- [[http://groups.csail.mit.edu/mac/projects/studentaut/DR%20HK%20Bio.htm][CAD史的]]にも [[https://www.designworldonline.com/cadhistory/][1960 年にすでに]] 'Object Oriented' という単語がでてきている。OOP と
  ルーツをともにしている。

- 1960 年代、A.I. 第 1 の波 (-1974)の最中、最初に MIT にでかいファンディングが政府か
  ら(当時の ARPA [fn:4], 現 DARPA, 1963)おちる、今の物価換算にすると 22 億円の出資。 -> ポリシーとして、プ
  ロジェクトではなく人にお金を使う。(licklider, Internet, ARPA, GUI の人)-> ハッカー文化の醸成。

- LISP 'atoms'[fn:1], 'S-expression'
  - 'コードとデータを均質に記述し扱うのに便利'
    - flow と structure を同時に扱う。
  - 1986- [[https://en.wikipedia.org/wiki/AutoLISP][AutoLISP]]

# LLVM ターゲットの Lisp とかもっと流行らないかなー

* 建築情報{学会}での使われ方

** ベタな話

じゃんじゃん、内規や予算、どんどん git(hub)にのっけていきましょう。

** メタな話

この話、建築{情報}学会ならではでしょう。

空間的な思考に強い建築と情報という(通信)流れに強い分野でいうと、履歴情報をあつか
うヴァージョニングこそが、深みを与えるものです。

デジタルデザインで履歴や"歴史"に注目してやった例はまだまだ少ないと思います。ジオ
メトリやその生成にかんしての知見は溜っているのでそれに今度はどのように時間を表現
して、"生命情報化"するかという問いです。(デジタル)デザインにおける「時間」のとら
えかたは以下の道筋(スケール)があるように見えます。

1. プログラムそのもののフローとしての時間
遺伝的アルゴリズムや DeepLearning 等もふくめて、ある処理がフローとして図示される
テクニックはすでにあります。ABM(Agent Based Model) 等も時間経過をシミュレーションして可視化する手法
です。もっと乱暴に言えば、プログラムは全て情報の流れです。

2. 設計のプロセス論としての時間
git や今回のレクチャーはこれを差すことがおおかったとおもいます。

3. 史学としての時間
複数のプログラムや、ひとつでもそれが長くなり、まとまって歴史とみることもできそう
です。Linux も 30 年立ちました。生成アルゴリズムやプログラムがこれくらいのスパン
で生きつづける状態が設計の現場でおこる状態をみてみたい気もします。あるいは、設計
者そのものも形態生成アルゴリズムと捉えれば、そのミームの伝達がいかように行なわれ
ているか。またそれを図示する方法ももしかしたら情報技術が役に立つかもしれません。

* おわりに

git そのものが使えるというのは自慢になりません。前提知識です!さっさと覚えて、*み
んな*で楽しい事しましょう。履歴管理していないようなプログラム・考えかたは出来る
だけ避けましょう。

[fn:1] 今でこそ、OOP とは違ったパラダイムとして、やっぱり LISP からの系統の関数
型言語が再注目されていますが。

[fn:2] 実際は制限ありますが、まずないものでいいです。

[fn:3] いっちゃえば、blockchain は巨大な超遅い DB です。

[fn:4] Internet の前身といえば、ARPANET ですね。
